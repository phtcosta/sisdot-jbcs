%% BioMed_Central_Tex_Template_v1.06
%%                                      %
%  bmc_article.tex            ver: 1.06 %
%                                       %

%%IMPORTANT: do not delete the first line of this template
%%It must be present to enable the BMC Submission system to
%%recognise this template!!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                     %%
%%  LaTeX template for BioMed Central  %%
%%     journal article submissions     %%
%%                                     %%
%%          <8 June 2012>              %%
%%                                     %%
%%                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                 %%
%% For instructions on how to fill out this Tex template           %%
%% document please refer to Readme.html and the instructions for   %%
%% authors page on the biomed central website                      %%
%% http://www.biomedcentral.com/info/authors/                      %%
%%                                                                 %%
%% Please do not use \input{...} to include other tex files.       %%
%% Submit your LaTeX manuscript as one .tex document.              %%
%%                                                                 %%
%% All additional figures and files should be attached             %%
%% separately and not embedded in the \TeX\ document itself.       %%
%%                                                                 %%
%% BioMed Central currently use the MikTex distribution of         %%
%% TeX for Windows) of TeX and LaTeX.  This is available from      %%
%% http://www.miktex.org                                           %%
%%                                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% additional documentclass options:
%  [doublespacing]
%  [linenumbers]   - put the line numbers on margins

%%% loading packages, author definitions

\documentclass[twocolumn]{bmcart}% uncomment this for twocolumn layout and comment line below
%\documentclass{bmcart}

%%% Load packages
%\usepackage{amsthm,amsmath}
%\RequirePackage{natbib}
%\RequirePackage[authoryear]{natbib}% uncomment this for author-year bibliography
%\RequirePackage{hyperref}
\usepackage[utf8]{inputenc} %unicode support
%\usepackage[applemac]{inputenc} %applemac support if unicode package fails
%\usepackage[latin1]{inputenc} %UNIX support if unicode package fails


\usepackage{booktabs} % For formal tables
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{enumerate}
\usepackage{ragged2e}

\usepackage{lstcustom}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                             %%
%%  If you wish to display your graphics for   %%
%%  your own use using includegraphic or       %%
%%  includegraphics, then comment out the      %%
%%  following two lines of code.               %%
%%  NB: These line *must* be included when     %%
%%  submitting to BMC.                         %%
%%  All figure files must be submitted as      %%
%%  separate graphics through the BMC          %%
%%  submission process, not included in the    %%
%%  submitted article.                         %%
%%                                             %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\def\includegraphic{}
%\def\includegraphics{}



%%% Put your definitions there:
\startlocaldefs
\lstdefinelanguage{Xtext}[]{Java}{
	morekeywords={grammar, with, hidden, generate, as, import, returns, current, terminal, enum},
	keywordstyle=[2]{\textbf},
	morestring=[b]",
	tabsize=2,
	numbers=left, 
	numbersep=2pt,
	numberblanklines=false,
	xleftmargin=2em,
	frame=single,
	framexleftmargin=1.5em
}
\newcommand{\lstXtext}[1]{\lstinline[breaklines=true,language=Xtext,basicstyle=\listingsfontinline,mathescape,literate={\-}{}{0\discretionary{-}{}{}}]\S#1\S}


\lstdefinelanguage{DRL}[]{Java}{
	morekeywords={rule, when, from, accumulate, and, not, in, then, for, int, end},
	keywordstyle=[2]{\textbf},
	morecomment=[l]{//}, 
	morecomment=[s]{/*}{*/}, 
	morestring=[b]",
	tabsize=2,
	numbers=left, 
	numbersep=2pt,
	numberblanklines=true,
	xleftmargin=2em,
	frame=single,
	framexleftmargin=1.5em
}

\lstdefinelanguage{Freemarker}[]{Java}{
	morekeywords={if, assign, else},
	keywordstyle=[2]{\textbf},
	morecomment=[l]{//}, 
	morecomment=[s]{/*}{*/}, 
	morestring=[b]",
	showspaces=false,
	tabsize=2,
	numbers=left, 
	numbersep=2pt,
	numberblanklines=false,
	xleftmargin=2em,
	frame=single,
	framexleftmargin=1.5em
}

\lstdefinelanguage{DSL}[]{Java}{
	morekeywords={rule, type, materials, conditions, cond, values},
	keywordstyle=[2]{\textbf},
	morecomment=[l]{//}, 
	morecomment=[s]{/*}{*/}, 
	morestring=[b]",
	showspaces=false,
	tabsize=2, 
	numbers=left, 
	numbersep=2pt,
	numberblanklines=false,
	xleftmargin=2em,
	frame=single,
	framexleftmargin=1.5em
}

\lstdefinelanguage{Cucumber}[]{Java}{
	morekeywords={Feature, Scenario, Given, And, When, Then},
	keywordstyle=[2]{\textbf},
	morecomment=[l]{//}, 
	morecomment=[s]{/*}{*/}, 
	morestring=[b]",
	showspaces=false,
	tabsize=2,
	numbers=left, 
	numbersep=3pt,
	numberblanklines=false,
	xleftmargin=2em,
	frame=single,
	framexleftmargin=1.5em
}

\lstdefinelanguage{Plugin}[]{Java}{
	morekeywords={plugin, groupId, artifactId, version, executions, execution, id, configuration, seed, qcs, goals, goal},
	keywordstyle=[2]{\textbf},
	morecomment=[l]{//}, 
	morecomment=[s]{/*}{*/}, 
	morestring=[b]",
	showspaces=false,
	tabsize=2
}

\newcommand{\callers}{\emph{high-level rules}\xspace}
\newcommand{\shc}{HLR\xspace}
\newcommand{\hlrdsl}{\textsc{HLRDsl}\xspace}



\endlocaldefs




%%% Begin ...
\begin{document}


%%% Start of article front matter
\begin{frontmatter}

\begin{fmbox}
\dochead{Research}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the title of your article here     %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{On the Use of Metaprogramming and Domain Specific Languages: An Experience Report in the Logistics Domain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the authors here                   %%
%%                                          %%
%% Specify information, if available,       %%
%% in the form:                             %%
%%   <key>={<id1>,<id2>}                    %%
%%   <key>=                                 %%
%% Comment or delete the keys which are     %%
%% not used. Repeat \author command as much %%
%% as required.                             %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\author[
   addressref={aff1},                   % id's of addresses, e.g. {aff1,aff2}
   corref={aff1},                       % id of corresponding address, if any
   %noteref={n1},                        % id's of article notes, if any
   email={pedro.costa@aluno.unb.br}   % email address
]{\inits{PHT}\fnm{Pedro HT} \snm{Costa}}
\author[
   addressref={aff1},
   corref={aff1},
   email={ednacanedo@unb.br}
]{\inits{ED}\fnm{Edna Dias} \snm{Canedo}}
\author[
	addressref={aff1},
	corref={aff1},
	email={rbonifacio@unb.br}
]{\inits{RB}\fnm{Rodrigo} \snm{Bonif\'{a}cio}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter the authors' addresses here        %%
%%                                          %%
%% Repeat \address commands as much as      %%
%% required.                                %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\address[id=aff1]{%                           % unique id
  \orgname{Computer Science Department, University of Bras\'{i}lia - (UnB)}, % university, etc
  \street{P.O. Box 4466},                     %
  \postcode{70910-900}                                % post or zip code
  \city{Bras\'{i}lia},                        % city
  \cny{BR}                                    % country
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Enter short notes here                   %%
%%                                          %%
%% Short notes will be after addresses      %%
%% on first page.                           %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{artnotes}
%\note{Sample of title note}     % note to the article
%\note[id=n1]{Equal contributor} % note, connected to author
\end{artnotes}

%\end{fmbox}% comment this for two column layout

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% The Abstract begins here                 %%
%%                                          %%
%% Please refer to the Instructions for     %%
%% authors on http://www.biomedcentral.com  %%
%% and include the section headings         %%
%% accordingly for your article type.       %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstractbox}

\begin{abstract} % abstract
\justify
In this paper we present the main design and architectural decisions to build an enterprise system that deals with the distribution of equipment to the Brazilian Army. The requirements of the system are far from trivial, and we have to conciliate the need to extract business rules from the source code (increasing software flexibility) with the requirements of not exposing the use of declarative languages to use a rule-based engine and simplifying the tests of the application. Considering these goals, we present in this paper a seamless integration of meta-programming and domain-specific languages. The use of meta-programming allowed us to isolate and abstract all definitions necessary to externalize the business rules that ensure the correct distribution of the equipment through the Brazilian Army unities. The use of a domain specific language simplified the process of writing automatic test cases related to our domain. Although our architecture targets the specific needs of the Brazilian Army, we believe that logistic systems from other institutions might also benefit from our technical decisions.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% The keywords begin here                  %%
%%                                          %%
%% Put each keyword in separate \kwd{}.     %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{keyword}
\kwd{Software Architecture}
\kwd{Generative Programming}
\kwd{Domain Specific Languages}
\kwd{Military Logistics}
\end{keyword}

% https://cran.r-project.org/web/classifications/MSC.html
% MSC classifications codes, if any
%\begin{keyword}[class=AMS]
%\kwd[Primary ]{}
%\kwd{}
%\kwd[; secondary ]{}
%\end{keyword}

\end{abstractbox}
%
\end{fmbox}% uncomment this for twcolumn layout

\end{frontmatter}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% The Main Body begins here                %%
%%                                          %%
%% Please refer to the instructions for     %%
%% authors on:                              %%
%% http://www.biomedcentral.com/info/authors%%
%% and include the section headings         %%
%% accordingly for your article type.       %%
%%                                          %%
%% See the Results and Discussion section   %%
%% for details on how to create sub-sections%%
%%                                          %%
%% use \cite{...} to cite references        %%
%%  \cite{koon} and                         %%
%%  \cite{oreg,khar,zvai,xjon,schn,pond}    %%
%%  \nocite{smith,marg,hunn,advi,koha,mouse}%%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







%%%%%%%%%%%%%%%%%%%%%%%%% start of article main body
% <put your article body there>

%%%%%%%%%%%%%%%%
%% Background %%
%%



\input{introduction}
\input{background}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Architectural Decisions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architectural Decisions}
\label{sec:architecture} 

SISDOT is based on the client-server architectural style (according to a typical Java enterprise application), where the components interact to each other by requesting services from other components~\cite{clements2011documenting}. SISDOT is also organized into logical groups of components (known as tiers)---a strategy often used in the client-server architectural style. The multi-tier architectural pattern can be classified as a \emph{component and connector} pattern, depending on the criterion used to define the tiers~\cite{bass2013software}. Indeed, there are several criteria, such as component type, sharing of the execution environment, 
and so on~\cite{clements2011documenting}.

The multi-tier pattern also induces some topological constraints that govern how the components might interact with other components. 
Specifically, connectors might only exist between components of the same tier or that reside in an adjacent tier~\cite{clements2011documenting}. In addition, according to Bass et al., the organization of a system using tiers supports software maintenance, facilitates the definition of security policies, and might increase the performance, availability, and modifiability of 
the systems~\cite{bass2013software}. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Runtime Architectural Description for QDM Generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Runtime Architectural Description for QDM Generation}

In order to further detail and illustrate the SISDOT architecture, and the main architectural decisions to address the constraints introduced in Section~\ref{sec:logistics}, here we present a scenario that refers to the generation of QDMs using a runtime architectural description, whose components, relationships, and interactions are illustrated in Figure~\ref{fig:runtime_qdm}). 

\begin{figure}[!ht] %\centering
	\includegraphics[scale=0.49]{img/runtimeView_qdm.png}
	\caption{Runtime view of the architecture} 
	\label{fig:runtime_qdm}
\end{figure}

\textcolor{red}{arrumar exemplo mais completo de DRL}

\textcolor{red}{falar sobre as regioes da DRL? (qc, fracao, cargo)}

\begin{lstlisting}[frame=single, float=*t, language=DRL, caption=Example of a \emph{low-level Drools rule}, label={code:drl}]
rule "HLR 1"   	
  when
    $qc: QuadroDeCargosVO( 
       (operational == OPERATIONAL || operational == NOT_OPERATIONAL)
       , natureId not in (50, 51)
       , valueId in (23, 41, 90, 50, 42, 31, 21, 32, 20, 30, 40) 
    )	
    $roles: List( size > 0 ) from accumulate ( 
      $dep: DepartmentVO(
         depId not in (14086, 1130)
      ) from $qc.deps 
      and
      $role: RoleVO(
         function == "ROLE"
         , roleId not in (364, 539, 121, 2205, 528, 2204, 539) 
         , rankId in (24, 23, 44, 22, 42) 
         , armsId not in (1055, 10, 833, 5308, 5393, 729, 5110, 15, 5112, 5390, 12) 
      ) from $dep.roles 
      and  		
      QualificationVO(
         code not in ("782", "756", "793", "768", "765", "751", "921", "749", "767", "748")
      ) from $role.qualifications
      and
      ObservationVO(
         code in ("40D","40K")
      ) from $role.observations;
	
      collectList( $role )
    )	 		
  then		 
    for(int i=0; i < $roles.size(); i++){       	
      RoleVO c = (RoleVO) $roles.get(i);
      helper.add(1051000007, c.getDepartmentId(), c.getRoleId());
    }
end
\end{lstlisting}

\emph{Considering the user interaction}, a previously authenticated specialist on the distribution of equipment throughout the Brazilian Army, using her web browser, requests the web page that allows the generation of QDMs (one of the main products of SISDOT). 
After selecting the \emph{generic organizational unity} for which a QDM would be generated, the system sends a request to the server. The client tier is responsible for these actions. The request is then received by a component of the presentation tier, more specifically by a \emph{managed bean} that works as a \emph{front controller} (in this case, a JSF controller). 

This controller validates the request data, before sending a new request to the business tier. In the business tier, the service 
that implements the business rules related to the QDM domain object is invoked to start the QDM generation process, which includes actions to (a) transform \callers into the \emph{low-level rules} specified using the Drools Rule Language (DRL), (b) execute these rules to instantiate a business object that represents a QDM, and (c) save this object in the persistence layer (a relational database). 

This process for generating a QDM starts by retrieving a list of previously registered \callers. An \shc, regardless of its type (either based on the full structure of the organization or based on its components), is related to one or more \emph{military materials / equipment} (MEMs) and defines the respective amount that should be assigned to a military unit (which ranges from an organization, a center, a department, a brigade, or even a military function or qualification of a soldier). 

A high-level rule has one or more distribution rules. Each rule has a type, a value, and an associated description. For example, a rule for a department type has the value of the department identifier and the description of the department name. For a better use of the database, avoiding the definition of numerous columns that would inevitably be null for several rule types, we decided to persist the distribution rules of an \shc using JSON (JavaScript Object Notation), which is converted back to an object when it is retrieved. The set of these rules defines exactly who should receive the MEMs specified by the \shc.

One of the factors that motivated the use of a rule based engine was the similarity between \callers and the ``if-then'' rules of these mechanisms.  %whose essential structure is shown in Listing~\ref{code:drlStructure}.
An \shc has a set of conditions that fits the conditional part of a rule (``if'') and has a set of actions (``then'') that, in this case, trigger the distribution of MEMs throughout the expected military unities.

%\begin{lstlisting}[frame=single, caption={Structure of a rule specified in Drools}, label={code:drlStructure}]
%rule "name"
%    attributes
%    when
%        LHS
%    then
%        RHS
%end
%\end{lstlisting}


The list of retrieved \callers contains only Java objects. In order to be able to use the rule engine in a transparent way for the end users (and also for developers in future maintenance scenarios), we decided to use a meta-programming approach, translating these objects into a set of rules (a program in logic programming) that might be used by a rule-based engine. As mentioned before, we decided to use the \emph{Drools rule-based engine} in the context of SISDOT (Figure \ref{fig:runtime_qdm}), mostly because of its integration capabilities with both JEE systems and the Wildfly application server. Accordingly, the \callers are translated into DRL rules (Listing~\ref{code:drl} presents an example of a \emph{low-level Drools rule}). To this end, we use a template engine (FreeMaker) to implement this particular transformation (Figure \ref{fig:runtime_qdm}), using a template that contains the required \emph{markups} for transforming \shc into \emph{low-level} Drools rules. That is, for each \shc, the template engine populates the template, resulting in a DRL rule consistent with the converted \shc.
% A code snippet of the template used for DRL generation can be seen in Appendix A. 

The RHS of the Drools rule of Listing~\ref{code:drl} iterates over all selected military roles (that satisfy the constraints of the LHS). We use a helper class to assign the equipment id (in this case a \emph{rifle} whose id is 1051000007) to the individual roles. Besides providing means to populate a QDM, this helper class also checks some constraints related to the QDM domain model. 
%\begin{figure}[!ht] \centering
%	\includegraphics[width=.48\textwidth]{img/artigo_template.jpg}
%	\caption{\it Freemarker template for generating DRL} 
%	\label{fig:template}
%\end{figure}


A QDM is generated for a generic organizational unity (hereafter QC, from \emph{Quadro de Cargos} in Portuguese), selected by the user on the client tier. Therefore, the user-specified QC must be retrieved from the Brazilian Army's enterprise database through a specific Data Access Object (DAO) in the data tier~\cite{alur2003}. From the list of DRL rules, created based on existing \callers, the rule engine is instantiated and these rules are compiled, so that they can be triggered by Drools. The QC domain object is then inserted into the working memory as a fact, an information that is always considered true. The rules are only executed when their conditions are satisfied, based on the specified QC organizational structure. When a rule is valid, that is, it has been activated and the \emph{Left Hand Side} (LHS) conditions are valid, the QDM is populated with the MEMs specified in the \emph{Right Hand Side} (RHS) of the rules. Therefore, we generate a complete QDM object after verifying all valid rules (previously registered in the database) for the selected QC. 

After generating a QDM domain object, it is saved on the database and we let the domain expert know of the success of the operation using a simple user interface message. The domain expert can then perform the necessary operations on the generated QDM, including a workflow involving  its edition, homologation, and validation.  



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% A Domain Specific Language for testing QDM Generation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A Domain Specific Language for testing QDM Generation}

As explained before, to generate a QDM, a set of \callers must be previously declared. This is a time-consuming task, particularly when using the interface of the system. In order to facilitate the definition of the \callers used in the automated test scripts, we decided to implement \hlrdsl---a DSL (Domain Specific Language) that enables us to specify \callers in a clear, objective, and declarative way (and most important, without using the interface of the SISDOT system). 

We implemented \hlrdsl  using Xtext, which generates plugins that allow code editing in both Eclipse and IntelliJ, plus an editor that can be embedded in a web application. This way, a developer writing test scripts might use \hlrdsl to take advantages of the functionality provided by these plugins. To implement a DSL using Xtext, it is first necessary to declare a grammar expressed using a syntax similar to ANTLR~\cite{parr2013}. Listing~\ref{code:gramatica} presents the grammar of our DSL. From this grammar,the Xtext tool suite generates a lexer, a parser, a set of classes representing the AST (Abstract Syntax Tree), and an editor with several features typically available in IDEs.
% Although Xtext provides an interesting implementation for all these concerns, a language designer is also able to customize several of the Xtext outcomes~\cite{bettini2016}.


\begin{lstlisting}[frame=single, language=Xtext, caption={\it Xtext grammar defining the DSL structure}, label={code:gramatica}]
grammar br.unb.cic.sisdot.chamador.HLRDsl 
with org.eclipse.xtext.common.Terminals
generate hlrdsl "http://www.unb.br/sisdot/hlrdsl"

Model:
rules += Rule*;

Rule:
'rule' code = INT '{'
('type' '=' type=OmType ',')?
'materials' '=' '['items+=Item (',' items+=Item)*'],'
'cnds' '=' '['cnds+=Condition (',' cnds+=Condition)*']'
'}';

Item: '(' codot=STRING (':' name=STRING)? ':' amount=INT ')';

Condition:
'(' ('cond' '=' cond=ConditionType ',')?
'type' '=' type = RuleType ','
'values' '=' '[' values+=STRING (',' values+=STRING)* ']'
')';

enum OmType: BOTH | OPERATIONAL | NOT_OPERATIONAL;
enum ConditionType: AFF | NEG;
enum RuleType: NATURE | SUB_NATURE | VALUE | DEPARTMENT | ARMS | ROLE_QC | SUB_CIRCLE | RANK | ROLE | QUALIFICATION | OBSERVATION ;
\end{lstlisting}

Listing \ref{code:dslExample} presents a simple example of a \shc declaration using our DSL. The goal of this rule is to distribute 
the materials (defined in the list of materials construct) for \emph{operational} OMs (see the type construct) and militaries \emph{not working in the specified list of departments} with a set of qualifications and roles. \textcolor{red}{While the definition of this rule using our DSL requires 12 lines of code, the corresponding definition of the same rule using a Java test case requires more than 50 lines of imperative code.}

\begin{small}
	\begin{lstlisting}[frame=single, language=DSL, caption={\it Example of a \shc declaration using our DSL}, label={code:dslExample}]
rule 1 { 
    type = OPERATIONAL, 
    materials = [ 
        ("1051000007" : "Rifle" : 1), 
        ("1020100011" : "Rifle Carrying Case" : 2)
    ], 
    cnds = [ 
        (cond=NEG, type=DEPARTMENT, values=[14086 , 1130]),
        (type=QUALIFICATION, values=[782, 756]), 
        (type=ROLE, values=[2, 12, 15, 21])
    ]
}
	\end{lstlisting}
\end{small}

Our first test approach consists first in the specification of the required \callers in a \hlrdsl file. Next, the \emph{behavior under test} is detailed as features using the Cucumber~\cite{wynne2017cucumber} framework (we present an example of a feature in Listing \ref{code:cucumber}). After that, the developer details the implementation steps of the features by (a) specifying which \callers(previously declared using our DSL) should be considered in the test execution, (b) specifying which QC the QDM should be generated, and (c) specifying the expected results in terms of the properties of the expected QDM. To this typical scenario, we use a testing  infrastructure that supports several facilities, that aims to increase productivity, such as: database connectivity, auxiliary methods for executing queries in the database, and predeclared rules in the rule engine.

That is, \hlrdsl simplifies the process of specifying \callers and its primary goal was to assist in test activities. However, after presenting to domain experts some examples of \callers specified using our DSL, we realized that \hlrdsl might also be useful to simulate the specification of rules, allowing a better understanding of the effect of each \shc for building QDMs.

\begin{lstlisting}[frame=single, language=Cucumber, caption={\it Cucumber feature}, label={code:cucumber}]
Feature: QDM 757311
As a user
I want to generate a QDM from HLRs

Scenario: Test 1
Given QC with code 757311
And HRL: 1, 2
When I generate a QDM
And the results are consistent
Then positions must be populated
| idDep    | idPos   | codot      | amount |
| 6765748  | 10403   | 1051000025 | 1      |
| 6765748  | 10403   | 1020100017 | 1      |
| 6765748  | 10403   | 1020100013 | 1      |
| 6765748  | 10403   | 1051000006 | 1      |
| 6765748  | 21328   | 1051000025 | 1      |
| 6765750  | 10122   | 1051000025 | 1      |    
| 6765793  | 13276   | 1051000025 | 6      |
| 6765796  | 24655   | 1051000025 | 1      |
| 6765796  | 24429   | 1051000025 | 2      |
| 6765798  | 24429   | 1051000025 | 3      |
| 6765798  | 11433   | 1051000025 | 9      |   
And the final result must be:
| codot      | amount |
| 1020100013 | 74     |
| 1020100017 | 74     |
| 1051000006 | 74     |
| 1051000025 | 74     |

\end{lstlisting}

Our second test approach automatically generates test cases from our DSL and from a random sample of simple combinations that characterize artificial organizational unities. This \emph{property based approach} involves a custom Maven plugin that currently generates simple test cases, freeing the tester to create only complex tests related to the QDM generation. 

\textcolor{red}{These test cases are generated from a combination of conditions, for example: one test case only for operational OMs and another for non-operational OMs; a test case for the different kinds of OMs (artillery, infantry, cavalry, aviation and helicopters, general services, and so on), combining with the operational type, such as: operational infantry OMs and non-operational infantry OMs. These combinations are generated for simple cases so that they are easy to verify without the need to manually implement Java test scripts for generating QDMs.}

O Maven plugin desenvolvido define diversos cenários que serão gerados para cada QC declarado. Cada cenário é responsável pela geração de uma high-level rules no formato DSL e um arquivo de definição do cenário no formato do cucumber. Para cada cenário é gerado um QDM para o QC, usando a high-level rule gerado e o resultado deste QDM é conferido de acordo com os dados previstos na definição do cenário do cucumber. Foram criadas diversas combinações de cenários e para cada uma delas alguns dos valores das propriedades são gerados randomicamente, seguindo a técnica PBT. 

Os cenários de teste foram divididos em três grupos, de acordo com as seções da DRL (QC, fração e cargo). Isso foi feito pois cada região é testada de forma quase que independente, possuindo dependência apenas da validade da região anterior. Por exemplo: a região de fração só é avaliada se a região de QC tiver sido avaliada como verdadeira, então essas regiões podem ser testadas de forma independente ao assumir que a região anterior é verdadeira e que foram gerados casos de testes que ajudaram a validar o funcionamento das condições da região anterior. Ao assumir a independência dos grupos, para fins de teste, é possível focar nas combinações das propriedades de cada grupo, facilitando a geração de cenários de teste. 

Cada grupo de cenários é responsável por testar várias das combinações das propriedades da entidade relativa ao grupo (QC, fração ou cargo). Em cada cenário é definido uma high-level rule e uma lista com os resultados esperados, que são gerados de acordo com a combinação específica de propriedades deste cenário. Como o MEM definido na high-level rule não interfere na execução das regras, foi definido um MEM padrão para todas as high-level rules geradas, assim como a quantidade igual a um (unitário). Isso foi feito para diminuir a complexidade do algoritmo de geração ao não precisar acessar o banco de dados várias vezes para recuperar MEMs de forma randômica, tendo em vista que não interferem na avaliação das regras envolvidas na geração do QDM.

No grupo de QC existem as seguintes propriedades: operacionalidade, natureza, subnatureza e valor. Foram criados cenários específicos para cada propriedade e para combinações entre elas. Para a propriedade natureza do QC, por exemplo, foram definidos os seguintes cenários:

\begin{itemize}

\item natureza válida e tipoOM válido: este cenário gera um QDM válido, com resultados válidos, pois neste cenário é criado um high-level rule com os mesmos valores de natureza e operacionalidade (tipoOM) do QC para o qual será gerado o QDM, ou seja, natureza e tipoOM válidos;

\item natureza válida e tipoOM válido (AMBOS): este cenário funciona de forma parecida com o anterior, mas o tipoOM é definido como "AMBOS" no high-level rule. Este tipoOM indica que o QC pode ser operacional ou não-operacional;

\item natureza válida e tipoOM inválido: o valor da natureza é o mesmo do QC, pois é válido, e o valor do tipoOM é alterado. Por exemplo: se o QC for operacional o valor é alterado para não-operacional e vice-versa;

\item natureza inválida e tipoOM válido: o valor da natureza deve ser inválido no high-level rule, ou seja, um valor diferente da natureza do QC. A geração deste valor inválido de natureza é realizado de forma randômica, usando a seed configurada no plugin maven, em uma lista de códigos de naturezas reais previamente definida;

\item natureza inválida e tipoOM inválido: os valores de natureza e tipoOM são inválidos, e são gerados conforme citado anteriormente: invertendo o valor de operacionalidade e recuperando randomicamente um código de natureza da lista declarada previamente;

\item negar natureza, inválido: as combinações citadas anteriormente nesta lista possuem high-level rules com regras do tipo "AFIRMACAO", o tipo padrão de uma regra. Mas existe o tipo "NEGACAO", onde a regra é negada, ou seja, a condição (na DRL) é válida quando o valor testado não pertence à lista de valores especificados na regra. Neste cenário, por exemplo, há uma regra de negação da natureza de forma que o QDM seja inválido. Então foi criada uma regra para "NATUREZA" do tipo "NEGACAO" definindo como valor o código da natureza do QC. Com isso, esta regra não é válida para este QC, sendo válida para todas as outras naturezas exceto a deste QC;

\item negar natureza, válido: para este cenário é criado uma high-level rule com uma regra para "NATUREZA" do tipo "NEGACAO", mas gerando um código de natureza diferente da natureza do QC. Com isso, esta regra é válida para este QC.
\end{itemize}

Seguindo a mesma linha de combinações utilizadas paras cenários envolvendo natureza do QC, foram criados cenários para subnatureza e valor. Não foram criados cenários para tipoOM pois esta é uma propriedade de preenchimento obrigatório no high-level rule e a checagem de sua validade já é exercitada em todos os cenários do grupo. Na Table \ref{table:valor} são apresentados os cenários definidos para o Valor do QC e suas combinações. Na primeira coluna é apresentado o número do cenário, criado apenas para facilitar uma possível referência a uma linha específica da tabela. As outras colunas contém os valores das propriedades do QC sendo combinadas. A células com valor 0 indicam que o valor desta propriedade, indicada pela coluna, é inválido, ou seja, deverá ser selecionado um valor randomicamente de uma lista previamente definida e este valor deve ser diferente do valor que essa propriedade apresenta no QC. As células com o valor 1 indicam que o valor desta propriedade é válido, ou seja, é o mesmo valor definido no QC para esta propriedade. As células sem valor indicam que essa propriedade não faz parte da combinação. 

\begin{table}[htb!]
	\centering
	\caption{Cenários definidos para Valor de QC}
	\label{table:valor}
	\begin{center}
		\begin{tabular}{ccccc}
			\toprule
\textbf{Cenário} & \textbf{Valor} & \textbf{Subnatureza} & \textbf{Natureza} & \textbf{TipoOM} \\ \hline
1                & 0              &                      &                   & 0               \\ \hline
2                & 0              &                      &                   & 1               \\ \hline
3                & 1              &                      &                   & 0               \\ \hline
4                & 1              &                      &                   & 1               \\ \hline
5                & 0              &                      & 0                 & 0               \\ \hline
6                & 0              &                      & 0                 & 1               \\ \hline
7                & 0              &                      & 1                 & 0               \\ \hline
8                & 0              &                      & 1                 & 1               \\ \hline
9                & 1              &                      & 0                 & 0               \\ \hline
10               & 1              &                      & 0                 & 1               \\ \hline
11               & 1              &                      & 1                 & 0               \\ \hline
12               & 1              &                      & 1                 & 1               \\ \hline
13               & 0              & 0                    & 0                 & 0               \\ \hline
14               & 0              & 0                    & 0                 & 1               \\ \hline
15               & 0              & 0                    & 1                 & 0               \\ \hline
16               & 0              & 0                    & 1                 & 1               \\ \hline
17               & 0              & 1                    & 0                 & 0               \\ \hline
18               & 0              & 1                    & 0                 & 1               \\ \hline
19               & 0              & 1                    & 1                 & 0               \\ \hline
20               & 0              & 1                    & 1                 & 1               \\ \hline
21               & 1              & 0                    & 0                 & 0               \\ \hline
22               & 1              & 0                    & 0                 & 1               \\ \hline
23               & 1              & 0                    & 1                 & 0               \\ \hline
24               & 1              & 0                    & 1                 & 1               \\ \hline
25               & 1              & 1                    & 0                 & 0               \\ \hline
26               & 1              & 1                    & 0                 & 1               \\ \hline
27               & 1              & 1                    & 1                 & 0               \\ \hline
28               & 1              & 1                    & 1                 & 0               \\ \hline
		\end{tabular}
	\end{center}
\end{table}

No grupo Cargo existem as seguintes propriedades: código do cargo, subcírculo ao qual o cargo pertence, o posto (patente) necessário para ocupar o cargo, e a arma (Arma, Quadro ou Serviço) necessária para ocupar o cargo. O subcírculo está relacionado às graduações (posto/patente) existentes, servindo como uma forma de agrupamento. Por exemplo: o subcírculo superior agrupa as patentes de coronel, tenente-coronel e major; o subcírculo subalterno agrupa os tenentes. 

Para cada cenário do grupo de cargos foi selecionado um cargo aleatoriamente da lista de cargos do QC, utilizando a seed configurada no plugin maven. De acordo com o cargo selecionado são geradas as regras conforme a combinação de propriedades especificada para o cenário. Para cada cenário, além das regras, é gerada também uma lista contendo os resultados esperados, ou seja, os dados que se espera encontrar no QDM gerado para o QC. 

Para este trabalho foram especificados 100 cenários. Todos os cenários gerados, independente do grupo, contém um high-level rule, com as regras referentes à combinação de propriedades definida para o cenário, e uma lista de resultados esperados, que serão comparados com os dados do QDM gerado. Para cada QC declarado no plugin é gerada uma lista de cenários. Para cada QC é gerado um arquivo cucumber contendo os cenários definido para este QC. A geração do arquivo é realizada com o uso do Freemarker, usando um template previamente definido.

O processo de geração automática de testes pode ser resumido da seguinte maneira: o plugin maven deve ser declarado e configurado, indicando a lista com os códigos dos QCs para os quais devem ser gerados testes. Então, para cada QC da lista são gerados cenários, com variações em suas propriedades de acordo com o QC sendo testado. Os cenários gerados são transformados em arquivos do cucumber e de DSL, que representam os cenários gerados. Houve então uma conversão dos cenários gerados com base na técnica Property-based Testing (PBT) em casos de teste, por exemplo, que serão executados automaticamente durante a fase adequada do ciclo de vida de \textit{build} do maven. Existe a possibilidade de geração de relatório da execução dos testes em alguns formatos, como: html e json.

% \begin{lstlisting}[frame=single, language=Plugin, caption={\it Maven plugin for test generation}, label={code:plugin}]
% <plugin>
%   <groupId>xxx</groupId>
%   <artifactId>xxx</artifactId>
%   <executions>
%     <execution>
%       <id>execute</id>			
%       <configuration>
%         <seed>10</seed>				
%         <qcs>702311,762314,575311</qcs>				
%       </configuration>
%       <goals>
%         <goal>generate</goal>
%       </goals>
%     </execution>
%   </executions>
% </plugin>	
% \end{lstlisting}

\textcolor{red}{In this second approach, for each of the possible combinations, we generate a \shc that meets the conditions and a cucumber feature that exercises the \shc and compares the expected results declared in the feature. Each \shc is considered during the generation of the QDM to the QCs specified in the maven plugin.
That is, to use this architecture characteristic (here we consider testability as an architecture concern), we ``feed'' the maven plugin with a list of QC codes for which the QDMs should be generated, besides other optional information, which have default values, such as: database connection string, seed to be used in the random selection of values within a combination (e.g., considering 20 different kinds of organizational unities, randomly take 5 for generating the set of combinations), and the output directory where the code should be exported. }

After running the plugin, with the generated code, the tests are executed in a similar way to the test definitions detailed before. The tests run along with the other unit tests declared, whether DSL-based or not.








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Empirical Study
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Empirical Study}
\label{sec:case_study} 
For the validation of the proposed architecture we conducted an empirical study, which consists of the evaluation of the main architectural decisions of SISDOT, which relate to the generation of QDMs. The case study aims to answer the following research questions:

\begin{itemize}
	\item \textbf{RQ.1}: Does our proposed approach, based on meta-programming, generate correct QDMs?
	\item \textbf{RQ.2}: Does the use of a DSL reduce the effort necessary to implement the test cases that target QDM generation? 
	\item \textbf{RQ.3}: Does our proposed approach, based on meta-programming, generate QDMs within a satisfactory time-frame?
\end{itemize}

\textbf{RQ.1} deals with the most important concern: correctness regarding the QDM generation. It is intended to demonstrate that the solution not only automatically generates the rules, eliminating the work that the developer would have to implement the solution in Java, but also that the proposed approach leads to the expected QDMs when considering a well defined set of \callers. \textbf{RQ.2} is related to the productivity of the tester and demonstrates how much code the developer have to write when using our DSL, compared to the effort to specify \callers using the Java language in unit test cases. During the activities of requirements elicitation,we identified a softgoal stating the  acceptable time for generating a QDM, which should not be above 10 seconds, when using 1000 \callers. Thus, \textbf{RQ.3} serves to ensure that the QDMs are generated in a satisfactory time.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Data Collection and Analysis Procedures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data Collection and Analysis Procedures}

We answer our first question qualitatively using the focus group method. Although this might look like disappointing (under the perspective of more formal methods), we have strong evidences collected from the domain experts that our approach has produced correct QDMs. We believe that this correctness is due to several factors, including the involvement of the domain experts that helped us to full understand the requirements and the expertise of our development team. Nevertheless, the decision of not writing the low-level rules at the source code level, but instead using a program generation approach that has reduced significantly the effort needed to \emph{hand write} those rules, has also contributed to achieve this confidence about correctness. 

We use a quantitative approach to answer the other two research questions.
To this end, we collected two metrics: lines of code (LOC) and execution time. The choice of these two metrics is related to the size of the code, which may indicate higher productivity; and to the fulfillment of the functional requirement that determines the maximum execution time for QDM generation. 
\textcolor{red}{arrumar: nao sao 66}
In the quantitative assessment, we use as a benchmark 66 \callers. These \callers correspond to real rules used by the Brazilian Army to perform some tests related to the generation of QDMs. We converted each \shc written using JUnit to their correspondent one specified using our DSL.

{\color{red}rbonifacio:
  seria possivel explorar algo como cobertura de codigo aqui? ou
  explorar alguma coisa da abordagem PBT? Talvez, usando essa informacao,
  fosse possivel responder a primeira questao de pesquisa usando tanto uma
abordagem qualitativa quanto uma abordagem quantitativa.}

\subsection{Results of the Qualitative Assessment}

Para responder a primeira questão de pesquisa nós realizamos um grupo focal com os especialistas do negócio com o objetivo de verificar se os QDMs estavam sendo gerado corretamente pelo sistema e na percepção dos usuários.

Focus groups are carefully planned discussions, designed to obtain the perceptions of the group members on a defined area of interest. There are typically between 3 to 12 participants and the discussion is guided and facilitated by a moderator, who follows a predefined structure so that the discussion stays focused. The members are selected based on their individual characteristics as related to the session topic \cite{kontio2004using}. 

O grupo focal foi conduzido em três etapas. Na primeira etapa 
(\emph{defining the research problem}) o objetivo do grupo
focal foi definido como o nosso interesse em verificar se a abordagem
proposta produzia QDMs corretamente e como os usuários estavam
verificando essa corretude. Na segunda etapa (participant selection)
foi definido o perfil dos participantes: integrantes da equipe
responsável por gerar os QDMs para as organizações militares
do Exército Brasileiro. Tais participantes compreendem os
principais stakeholders e potenciais usuários finais do SISDOT.
Quatro participantes dessa equipe foram selecionados, sendo que
todos possuem conhecimento necessário para verificar
se o quadro de distribuição de materiais foi realizado
corretamente, de acordo com o esperado para cada organização militar,
com seu respectivo quantitativo de materiais e cargos.

Na terceira etapa (executing the focus group session) foi realizada o
levantamento das informações com o uso grupo focal, que teve duração
de 02 horas e meia e foi realizado nas dependências da 4a.
subchefia, responsável pela geração dos QDMs e execução do SISDOT.
O grupo focal foi conduzido e gerenciado por dois participantes do projeto, o responsável pelo levantamento dos requisitos e pelo arquiteto responsável pelo desenvolvimento da solução disponibilizada. Inicialmente, foi realizada uma explicação pelo time do projeto sobre os objetivos da realização do grupo focal e quais as expectativas da sua execução. Além disso, foram realizadas perguntas direcionadas aos participantes pelos moderadores. O papel dos dois moderadores foi conduzir as questões e fazer com que os participantes especialistas do negócio descrevessem como as atividades estavam sendo realizadas e verificada a sua conformidade. 

Analysis. The focus group session result was documented in the note used during the session and in the audio recording used during the session. Todos os participantes relataram terem executado a funcionalidade de geração de QDMs diversas vezes.
\emph{Foi reportado que em nenhuma das execuções levou a uma inconsistência}. Além disso, durante a execução do grupo focal o Major responsável pela 4ª Chefia fez questão de gerar um QDM e nos mostrar como era feita a verificação de conformidade, que segue uma estratégia em pares. Tal Major solicitou ao outro participante para verificar no quadro de cargos qual o quantitativo da OM verificada (AMAN), que é uma das OMs mais complexas em termos de cargos e de materiais necessários para que sejam realizadas as suas atividades militares. O quantitativo desejado e esperado de materiais foi devidamente registrado na geração do QDMs pelos chamadores utilizados para essa geração. Demonstrando assim a geração correta da funcionalidade.

Os participantes evidenciaram que a funcionalidade estava sendo realizada corretamente e que a atividade manual que eles realizavam se tornou prática, rápida e confiável. No final da atividade foi feito um agradecimento por parte do responsável pela chefia, dizendo que n\~{a}o imaginava atingir tão rapidamente o grau de corretude na distribuição dos materiais para as OMs.

\subsection{Results of the Quantitative Assessment} 

%%%%%%%%%%%%%%%%#######################

 Table \ref{table:comparacao} presents a sample of the collected data. The first column contains the \shc code, the second column contains the number of lines of code to represent the \shc using our DSL, and the third column contains the number of lines of code to represent the same rule in the Java language.

\begin{table}[htb!]
	\centering
	\caption{Comparing the number of lines of code need to specify test cases using our DSL and Java}
	\label{table:comparacao}
	\begin{center}
		\begin{tabular}{ccccc}
			\toprule
			\textbf{\shc Code} & \textbf{DSL} & \textbf{Java} & \textbf{Difference} & \textbf{\%}   \\ \midrule
1                 & 10           & 26            & 16                 & 62                      \\ 
2                 & 10           & 25            & 15                 & 60                      \\ 
3                 & 10           & 32            & 22                 & 69                      \\ 
4                 & 11           & 52            & 41                 & 79                      \\ 
5                 & 15           & 41            & 26                 & 64                      \\ 
6                 & 9            & 16            & 7                  & 44                      \\ 
7                 & 18           & 21            & 3                  & 15                      \\ 
8                 & 12           & 25            & 13                 & 52                      \\ 
9                 & 9            & 11            & 2                  & 19                      \\ 
10                & 11           & 23            & 12                 & 53                      \\ 
122               & 10           & 48            & 38                 & 80                      \\ 
123               & 8            & 44            & 36                 & 82                      \\ 
124               & 10           & 54            & 44                 & 82                      \\ 
125               & 8            & 39            & 31                 & 80                      \\ 
126               & 12           & 47            & 35                 & 75                      \\ 
127               & 9            & 43            & 34                 & 80                      \\ 
128               & 9            & 39            & 30                 & 77                      \\ 
129               & 9            & 27            & 18                 & 67                      \\ 
130               & 12           & 25            & 13                 & 52                      \\ 
131               & 12           & 45            & 33                 & 74                      \\ \bottomrule
		\end{tabular}
	\end{center}
\end{table}

Regarding the runtime metrics, we collected the data using an Intel(R) Core{TM} i7-4790 processor, with 16GB of RAM, running Ubuntu 16.04.4 LTS 64-bit operating system, with 4.15.0-24-generic kernel. We used 16 QCs, chosen to represent the various OM types, natures, and sub-natures. For each QC, we generated QDMs using random sets of \callers with size: 20, 40, 50, 60, 100, 200, 400, 700, 1000, 1500, 2000. Since there were only \textcolor{red}{66} real \callers already declared, larger quantities contain repeated \callers (which in the end will duplicate the data within a given QDM). The selection of \callers was performed at random, but with the same seed, so that the same sets were used in the generation of QDMs for different QCs. Table \ref{table:tempo} shows a sample of the results obtained with the execution. The first column contains the QC code, and the second column contains the time in milliseconds for the generation of the QDMs using the indicated amount of \callers on the respective column header.

\textcolor{red}{pegar tempos da dissertacao, incluir AMAN}

\begin{table}[htb!]
	\centering
	\caption{Time (ms) for generation of QDMs}
	\label{table:tempo}
	\begin{center}
		\begin{tabular}{lllllll}
			\toprule
			\textbf{QC}      & \textbf{60}  & \textbf{100} & \textbf{400}  & \textbf{700}  & \textbf{1000} & \textbf{2000} \\ \midrule
			
			206410  & 184 & 275 & 944  & 1829 & 2279 & 4707 \\ % \hline
			231303  & 197 & 282 & 975  & 1731 & 2541 & 4987 \\ % \hline
			500311  & 201 & 291 & 948  & 1804 & 2289 & 4950 \\ % \hline
			618322  & 175 & 264 & 922  & 1640 & 2412 & 4990 \\ % \hline
			727310  & 173 & 302 & 937  & 1652 & 2466 & 4992 \\ % \hline
			1450311 & 182 & 269 & 890  & 1649 & 2527 & 4785 \\ % \hline
			2203310 & 197 & 263 & 909  & 1619 & 2344 & 4976 \\ % \hline
			5406194 & 176 & 253 & 884  & 1598 & 2393 & 4610 \\ % \hline
			7020003 & 212 & 241 & 922  & 1610 & 2361 & 4470 \\ % \hline
			9131000 & 171 & 252 & 888  & 1609 & 2345 & 4471 \\ \bottomrule
		\end{tabular}
	\end{center}
\end{table}

We exported the collected data to the CSV format, so that we could perform a data analysis using the R environment~\cite{crawley2013}. In the data analysis for \textbf{RQ.2}, which compares the number of lines of code between the two distinct approaches for representing \callers, we created two additional columns: \emph{difference}, which measures the difference in the number of lines of code necessary to specify \callers using Java and our DSL; and \emph{percent of reduction}, which indicates how much less code is necessary to specify a \shc using our DSL, when compared to the direct specification in Java code.

\begin{table}[htb!]
	\centering
	\caption{Analysis of DSL and Java comparison data}
	\label{table:analiseComparacao}
	\begin{center}
		\begin{tabular}{lrrrrr}
			\toprule
			& \textbf{Min.}  & \textbf{Median} & \textbf{Mean}  & \textbf{SD}    & \textbf{Max.}  \\ \midrule
DSL         & 7.00  & 9.00   & 9.67  & 2.01  & 18.00  \\ 
Java        & 9.00  & 23.00  & 28.66 & 18.47 & 130.00 \\ 
Difference  & 2.00  & 13.00  & 18.98 & 18.25 & 121.00 \\ 
\%	        & 14.29 & 56.26  & 54.66 & 21.68 & 93.08  \\ \bottomrule
		\end{tabular}
	\end{center}
\end{table}

Table \ref{table:analiseComparacao} presents some descriptive statistics of the collected data, containing the following columns: minimum value, median, mean, standard deviation, and maximum value. There is a strong correlation (0.982) between the lines of code in Java and the \emph{difference} measurements. This correlation can be seen in Figure \ref{fig:correlacao}. It is possible to identify that as the size of the Java code grows, the difference for the representation in DSL also increases.

\textcolor{red}{regerar figuras em ingles}

\begin{figure}[htb!] 
	\centering
	\includegraphics[width=.45\textwidth]
	{img/artigo_correlacao.png}
	\caption{\it Correlation between Java and Difference}
	\label{fig:correlacao}
\end{figure}

Figure \ref{fig:geracao} shows the time necessary to generate QDMs for 5 different QCs. For each of them, 6 QMS were generated, with different amounts of \callers, 60, 100, 400, 700, 1000 and 2000.

\begin{figure}[!ht] \centering
	\includegraphics[width=.45\textwidth]
	{img/artigo_geracao.jpg}
	\caption{\it QDM Generation Time (ms)}
	\label{fig:geracao}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discussion, Lessons Learned, and Threats to Validity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion and Threats to Validity}

When analyzing the data related to RQ.2, it was possible to realize that the representation of a \shc using our DSL is on average 45\% smaller than the representation of the same rule in Java. This indicates a possible productivity gain for the developer when writing test cases, since she will have to write a smaller amount of code. In addition, using our DSL, we specify \callers using a declarative approach, which is close to the vocabulary of the problem domain. With respect to the third research question, the limit imposed by the functional requirement of 5 seconds was not exceeded, even when considering 2000 \callers, which is twice the number of \callers expected for the system in production. It is important to notice that these number (5 seconds as time limit and 1000 \callers were collected together with the stakeholders of SISDOT).

The general approach discussed in this paper involves the use of metaprogramming to generate low-level Drools rules from \callers and the use of a DSL to specify \callers during test activities. We have some previous experience using Drools, and, at the beginning of this research collaboration, we realized that the use of a rule based engine (such as Drools), could simplify the computation of QDMs
(one of the main products of SISDOT). Nevertheless, we should try to abstract the use of Drools, mostly due to architectural conformance---we should not introduce new languages during the development of SISDOT. For this reason, we applied a transformational approach, translating Java domain objects into Drools rules at runtime. Perhaps due to the structure of the \callers, the task of implementing this transformational approach was not difficult. We believe that it was the right decision considering the original set of requirements. Surely, a number of uncertainties arise, including: ``will our proposed approach support the expectations of the end-users w.r.t. correctness and time constraints?''. We address this question in our empirical evaluation.

However, we found that testing the process of QDM generation was time consuming, and then we designed a DSL to address the main bottleneck: the specification of \callers either using Java test scripts or the SISDOT user interface (the common way for specifying \callers). Our choice for using Xtext to this end had simplified the entire process for implementing a DSL. Even considering that \hlrdsl is a simple and small DSL, we argue that the set of Xtext tools is really simple and productive, reducing the overall effort to implement the \hlrdsl grammar, parser, and program generator. We could have used other tools and techniques as well, for instance
a metaprogramming approach to support our test activities. However, such approach would not have solved the main problem that motivated us to implement \hlrdsl. In this case, our goal was to design a simple approach for specifying \callers. In the end, \hlrdsl started to be considered an interesting approach for use not only in test activities, but also for simulating QDMs without the need to persist \callers in the production environment. 

Our empirical study presents several limitations. First, we discuss \emph{correctness} based on the results of both integration and acceptance tests, though also considering the opinion of the domain experts that are currently confident that our approach for QDM generation is working properly. Surely, we could have used a more formal approach for discussing correctness, and we postpone this investigation to a future work. Nevertheless, considering the scope of this paper, the feedback from the domain experts and testing outcomes reduce some of ours uncertainties about correctness. 

Second, we only considered 66 real \callers in our study, which served as a basis for measuring the time to generate QDMs. SISDOT is expected to have around 1000 \callers in the production environment. To mitigate the threat related to the small number of available \callers for testing, we considered their repetition when carrying out a performance test of SISDOT. In this way, we expect that the
system would present a behavior similar to the production environment (with respect to performance). The same situation occurs with the comparison of lines of code between the declarations of \callers in DSL and Java. As the number of \callers is relatively small, 
it may not be possible to generalize the results we found.









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Related Work
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
\label{sec:related}

We addressed the main architectural concerns of SISDOT using well-known patterns for enterprise systems~\cite{enterprise-patterns:book} and software architecture patterns ~\cite{pattern-oriented:book}. Moreover, the ideas of using rule based engines to support inference within software systems are also not new~\cite{ORDONEZ2016353,li2012modeling}, and have been particularly explored in the health domain~\cite{mantas2012comparing,li2012modeling,jung2011executing}. For instance, Van Hille et al. present a comparison between Drools and OWL + SWRL for implementing the reasoning procedures of the alert module of an implantable cardioverter defibrillator. The authors conclude that Drools provides greater expressiveness when compared to the other approach. Our decision to use Drools to implement low-level rules was mostly based on its integration to the JEE platform, instead of its expressiveness.
% We also considered the use of Prolog for at least
% expressing the mechanics of the QDM generation, though
% we postponed this work to a future work.

Dingcheng Li and colleagues report on the use of the Drools engine to model and reason about \emph{electronic health records}~\cite{li2012modeling}. To this end, the authors of this mentioned work implemented a \emph{model-to-model translational approach} that converts the specification of phenotyping algorithms expressed using the Quality Data Model (from the National Quality Forum\footnote{http://www.qualityforum.org/Home.aspx}) into Drools rules. Similarly, Jung et al. present an approach for executing medical logic modules expressed in ArdenML using Drools~\cite{jung2011executing}. They also used a model-to-model approach implemented using XSLT. Our approach could also be characterized as being based on \emph{model-to-model transformations}, since we translate a business entity model (represented as the \callers Java domain objects at runtime) into Drools rules, though using FreeMarker as template engine.
% The work of Ostermayer et al. also advocates
% the use of DSLs + template engines to generate Drools
% rules~\cite{toostermayer2013simplifying}.

Several DSLs have been proposed to support test activities. For instance, Mugridge and Cunningham present the \emph{Fit Framework for Integrated Tests}, which is based on a DSL~\cite{Mugridge:2005:FDS:1051337} The Cucumber framework also uses a DSL for expressing the expected behavior of software features~\cite{Wynne:2012:CBB:2331446}. Here, we designed a small DSL to reduce the effort for setting up a suite of acceptance tests (based on Cucumber) for QDM generation, particularly helping the test team to specify \callers. 









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Final Remarks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Final Remarks}
\label{sec:conclusao}

In this paper we detailed the main design and architectural decisions we use to implement the mechanisms necessary to support the distribution of materials through the Brazilian Army unities. These decisions included the use of a metaprogamming approach to derive high level business rules in rules specific to a rule based system (Drools) and the definition of a DSL that facilitates the declaration of \callers to build test scripts. 

We carried out an empirical study to validate the proposed architecture, based on the evaluation of one of the main scenarios of our logistic system (SISDOT), related to the generation of QDMs. From the results obtained, it was possible to observe a reduction in the average number of lines of code required for the declaration of a \callers using our DSL, in comparison with the representation of the same \shc in Java. Another result of the case study shows that our approach fulfills a non functional requirement that constraints the expected time to generate QDMs. This limit was not exceeded even when using twice the number of \callers expected for the system in production environment.

Although the architecture discussed here considers the specific needs of the Brazilian Army, we believe that logistic systems from other institutions might benefit from our technical decisions as well.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                          %%
%% Backmatter begins here                   %%
%%                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{backmatter}

\section{Competing interests}
  The authors declare that they have no competing interests.

\section{Author's contributions}
    Text for this section \ldots

\section{Acknowledgements}
We would like to thank the anonymous referees for the valuable comments and suggestions, which have led to several improvements of this paper. This work is partially supported by \textsc{PROMISE-EB}, a software modernization project involving the University of Bras\'{i}lia and the Brazilian Army.
  
  
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  The Bibliography                       %%
%%                                                         %%
%%  Bmc_mathpys.bst  will be used to                       %%
%%  create a .BBL file for submission.                     %%
%%  After submission of the .TEX file,                     %%
%%  you will be prompted to submit your .BBL file.         %%
%%                                                         %%
%%                                                         %%
%%  Note that the displayed Bibliography will not          %%
%%  necessarily be rendered by Latex exactly as specified  %%
%%  in the online Instructions for Authors.                %%
%%                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% if your bibliography is in bibtex format, use those commands:
\bibliographystyle{bmc-mathphys} % Style BST file (bmc-mathphys, vancouver, spbasic).
\bibliography{bibliography}      % Bibliography file (usually '*.bib' )
% for author-year bibliography (bmc-mathphys or spbasic)
% a) write to bib file (bmc-mathphys only)
% @settings{label, options="nameyear"}
% b) uncomment next line
%\nocite{label}

% or include bibliography directly:
% \begin{thebibliography}
% \bibitem{b1}
% \end{thebibliography}


\end{backmatter}


\end{document}
